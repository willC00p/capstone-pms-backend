import React, { useState, useCallback, useEffect } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import styles from './ParkingAssignmentPage.module.css';
import axios from 'axios';
import { FaPlus, FaMinus, FaExpand, FaCar } from 'react-icons/fa';

const ParkingAssignmentPage = () => {
    const navigate = useNavigate();
    const { layoutId } = useParams();
    const [layout, setLayout] = useState(null);
    const [selectedSlot, setSelectedSlot] = useState(null);
    const [showForm, setShowForm] = useState(false);
    const [showBackground, setShowBackground] = useState(true);
    const [scale, setScale] = useState(1);
    const [position, setPosition] = useState({ x: 0, y: 0 });
    const [lines, setLines] = useState([]);
    const [texts, setTexts] = useState([]);
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
    const [loading, setLoading] = useState(true);
    const [assignments, setAssignments] = useState({});
    const [formData, setFormData] = useState({
        assignee_type: 'guest',
        name: '',
        contact: '',
        vehicle_type: '',
        vehicle_plate: '',
        start_time: new Date().toISOString().slice(0, 16),
        end_time: '',
        purpose: ''
    });

    const fetchLayout = useCallback(async () => {
        try {
            const token = localStorage.getItem('token');
            const response = await axios.get(`http://localhost:8000/api/parking-layouts/${layoutId}`, {
                headers: { 'Authorization': `Bearer ${token}` }
            });
            const layoutData = response.data;
            
            console.log('Raw Layout Response:', response.data);
            
            if (!layoutData || !layoutData.data) {
                throw new Error('No layout data found in response');
            }
            
            const rawLayoutData = layoutData.data.layout_data || {};
            console.log('Raw layout_data:', rawLayoutData);
            
            // Ensure we have the proper data structure
            const processedLayout = {
                ...layoutData.data,
                layout_data: {
                    parking_slots: rawLayoutData.parking_slots || [],
                    lines: rawLayoutData.lines || [],
                    texts: rawLayoutData.texts || []
                },
                parking_slots: layoutData.data.parking_slots || []
            };
            
            console.log('Processed layout data:', processedLayout.layout_data);
            
            // Add image path for the background image
            if (processedLayout.background_image) {
                processedLayout.image_path = `/storage/${processedLayout.background_image}`;
            }

            console.log('Final Layout Data:', processedLayout);
            
            // Extract elements from layout_data
            const { lines = [], texts = [] } = processedLayout.layout_data || {};
            
            // Set the extracted elements and layout data
            setLines(lines);
            setTexts(texts);
            setLayout(processedLayout);
            
            // Add debug logging
            console.log('Layout Elements:', {
                lines,
                texts,
                parking_slots: processedLayout.parking_slots,
                lineCount: lines.length,
                textCount: texts.length,
                slotCount: processedLayout.parking_slots.length
            });
            setLoading(false);
        } catch (error) {
            console.error('Error fetching layout:', error);
            console.error('Error details:', error.response?.data);
            setLayout(null);
            setLoading(false);
        }
    }, [layoutId]);

    const fetchAssignments = useCallback(async () => {
        if (!layout) return; // Don't fetch assignments if layout isn't loaded
        
        try {
            const token = localStorage.getItem('token');
            const response = await axios.get(`http://localhost:8000/api/parking-assignments/active`, {
                headers: { 'Authorization': `Bearer ${token}` }
            });
            
            console.log('Raw assignments response:', response.data);
            
            // Convert assignments into a map keyed by parking_slot_id
            const assignmentsData = response.data?.data || [];
            const assignmentsMap = {};
            
            if (Array.isArray(assignmentsData)) {
                assignmentsData.forEach(assignment => {
                    if (assignment.parking_slot_id) {
                        // Make sure we include the assignment's ID
                        assignmentsMap[assignment.parking_slot_id] = {
                            ...assignment,
                            id: assignment.id // Ensure ID is included
                        };
                    }
                });
            }
            
            console.log('Processed assignments map:', assignmentsMap);
            
            // Update assignments state and create status map
            setAssignments(assignmentsMap);
            
            // Create a map of assignments for status updates
            const assignmentStatusMap = {};
            assignmentsData.forEach(assignment => {
                if (assignment && assignment.parking_slot_id) {
                    assignmentStatusMap[assignment.parking_slot_id] = true;
                }
            });
            
            // Update layout slot statuses to match assignments
            setLayout(prev => {
                if (!prev) return prev;
                return {
                    ...prev,
                    parking_slots: prev.parking_slots?.map(slot => ({
                        ...slot,
                        space_status: assignmentStatusMap[slot.id] ? 'occupied' : 'available'
                    })) || []
                };
            });
        } catch (error) {
            console.error('Error fetching assignments:', error);
            if (error.response?.data?.message) {
                console.error('Server error:', error.response.data.message);
            }
        }
    }, []);

    useEffect(() => {
        fetchLayout();
        fetchAssignments();

        // Set up polling for updates
        const pollInterval = setInterval(() => {
            if (layoutId) {
                fetchLayout();
                fetchAssignments();
            }
        }, 5000);

        return () => clearInterval(pollInterval);
    }, [layoutId, fetchLayout, fetchAssignments]);

    const [draggedAssignment, setDraggedAssignment] = useState(null);

    const handleSlotClick = (slot) => {
        if (slot.space_status !== 'occupied') {
            setSelectedSlot(slot);
            setShowForm(true);
            setFormData(prev => ({
                ...prev,
                parking_slot_id: slot.id
            }));
        }
    };

    const handleDragStart = (e, slot) => {
        if (slot.space_status === 'occupied') {
            e.stopPropagation();
            const assignment = assignments[slot.id];
            console.log('Starting drag with assignment:', assignment);
            if (!assignment) {
                console.error('No assignment found for slot:', slot.id);
                return;
            }
            setDraggedAssignment(assignment);
            e.dataTransfer.setData('text/plain', slot.id);
            e.dataTransfer.effectAllowed = 'move';
        }
    };

    const handleDragEnd = (e) => {
        e.preventDefault();
        setDraggedAssignment(null);
        setIsDragging(false);
    };

    const handleDragOver = (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    };

    const handleDrop = async (e, targetSlot) => {
        e.preventDefault();
        e.stopPropagation();
        
        console.log('Handling drop with assignment:', draggedAssignment);
        console.log('Target slot:', targetSlot);
        
        if (!draggedAssignment || !draggedAssignment.id) {
            console.error('No valid dragged assignment found');
            setDraggedAssignment(null);
            setIsDragging(false);
            return;
        }
        
        if (targetSlot.space_status === 'occupied') {
            console.error('Target slot is already occupied');
            setDraggedAssignment(null);
            setIsDragging(false);
            return;
        }

        try {
            const token = localStorage.getItem('token');
            await axios.post(
                `http://localhost:8000/api/parking-assignments/${draggedAssignment.id}/switch-parking`,
                {
                    new_slot_id: targetSlot.id
                },
                {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    }
                }
            );

            // Update the assignments state
            const oldSlotId = draggedAssignment.parking_slot_id;
            setAssignments(prev => {
                const newAssignments = { ...prev };
                delete newAssignments[oldSlotId];
                newAssignments[targetSlot.id] = {
                    ...draggedAssignment,
                    parking_slot_id: targetSlot.id
                };
                return newAssignments;
            });

            // Update the layout state
            setLayout(prev => ({
                ...prev,
                parking_slots: prev.parking_slots.map(slot => {
                    if (slot.id === oldSlotId) {
                        return { ...slot, space_status: 'available' };
                    }
                    if (slot.id === targetSlot.id) {
                        return { ...slot, space_status: 'occupied' };
                    }
                    return slot;
                })
            }));

            setDraggedAssignment(null);
            setIsDragging(false);
            alert('Parking space reassigned successfully!');
            
            // Refresh the assignments and layout
            await Promise.all([fetchAssignments(), fetchLayout()]);
        } catch (error) {
            console.error('Error reassigning space:', error);
            alert('Failed to reassign parking space: ' + (error.response?.data?.message || error.message));
        } finally {
            setDraggedAssignment(null);
            setIsDragging(false);
        }
    };

    const handleAssignment = async (e) => {
        e.preventDefault();
        try {
            const token = localStorage.getItem('token');
            
            // Prepare the assignment data with proper field names
            const assignmentData = {
                parking_slot_id: selectedSlot.id,
                guest_name: formData.name,
                guest_contact: formData.contact,
                vehicle_type: formData.vehicle_type,
                vehicle_plate: formData.vehicle_plate,
                start_time: formData.start_time,
                end_time: formData.end_time || null,
                notes: formData.purpose,
                assignee_type: formData.assignee_type
            };

            const response = await axios.post(
                'http://localhost:8000/api/parking-assignments',
                assignmentData,
                {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    }
                }
            );

            console.log('Assignment response:', response.data);
            
            // Extract the assignment data from the response and format it properly
            const newAssignment = {
                id: response.data.assignment.id,
                parking_slot_id: selectedSlot.id,
                guest_name: formData.name,
                guest_contact: formData.contact,
                vehicle_type: formData.vehicle_type,
                vehicle_plate: formData.vehicle_plate,
                start_time: formData.start_time,
                end_time: formData.end_time,
                notes: formData.purpose
            };
            
            // Update the assignments state with the new assignment
            setAssignments(prev => ({
                ...prev,
                [selectedSlot.id]: newAssignment
            }));

            // Update the slot status in the layout
            setLayout(prev => ({
                ...prev,
                parking_slots: prev.parking_slots.map(slot =>
                    slot.id === selectedSlot.id
                        ? { ...slot, space_status: 'occupied' }
                        : slot
                )
            }));

            setShowForm(false);
            setSelectedSlot(null);
            alert('Parking space assigned successfully!');
            
            // Refresh assignments
            fetchAssignments();
        } catch (error) {
            console.error('Error creating assignment:', error);
            alert('Failed to create parking assignment: ' + (error.response?.data?.message || error.message));
        }
    };

    const handleInputChange = (e) => {
        const { name, value } = e.target;
        setFormData(prev => ({
            ...prev,
            [name]: value
        }));
    };

    const handleMouseDown = useCallback((e) => {
        if (e.button === 0) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y
            });
        }
    }, [position]);

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = useCallback(() => {
        setIsDragging(false);
    }, []);

    const handleWheel = useCallback((e) => {
        e.preventDefault();
        const delta = e.deltaY * -0.01;
        setScale(s => Math.min(Math.max(s + delta, 0.1), 4));
    }, []);

    const resetView = () => {
        setScale(1);
        setPosition({ x: 0, y: 0 });
    };

    if (loading) {
        return <div className={styles.loading}>Loading parking layout...</div>;
    }

    if (!layout) {
        return <div className={styles.error}>Error loading layout. Please try again.</div>;
    }

    // Removed unused variables 'total' and 'occupied'

    return (
        <div className={styles.pageContainer}>
            <div className={styles.header}>
                <button onClick={() => navigate('/home/parkingspaces')} className={styles.backButton}>
                    ← Back to Parking Spaces
                </button>
                <h1>{layout.name} - Select a Space to Assign</h1>
                <div className={styles.controls}>
                    <button onClick={() => setScale(s => Math.min(s + 0.1, 4))}><FaPlus /></button>
                    <button onClick={() => setScale(s => Math.max(s - 0.1, 0.1))}><FaMinus /></button>
                    <button onClick={resetView}><FaExpand /></button>
                    <button 
                        onClick={() => setShowBackground(!showBackground)}
                        className={`${styles.bgToggle} ${!showBackground ? styles.bgHidden : ''}`}
                    >
                        {showBackground ? 'Hide Background' : 'Show Background'}
                    </button>
                </div>
            </div>

            <div 
                className={styles.layoutSection}
                onMouseDown={handleMouseDown}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
                onWheel={handleWheel}
            >
                <div className={styles.layoutWrapper}>
                    <div 
                        className={`${styles.layoutContainer} ${!showBackground ? styles.hideBg : ''}`}
                        style={{
                            backgroundImage: showBackground ? `url(http://localhost:8000${layout.image_path})` : 'none',
                            width: '1024px',
                            height: '768px',
                            transform: `translate(${position.x}px, ${position.y}px) scale(${scale})`,
                            backgroundSize: '1024px 768px',
                            backgroundPosition: 'center',
                            backgroundRepeat: 'no-repeat',
                            position: 'relative',
                            pointerEvents: 'auto',
                            backgroundColor: !showBackground ? '#1a1a1a' : 'transparent'
                        }}
                        onDragOver={(e) => {
                            e.preventDefault();
                            e.stopPropagation();
                        }}
                    >
                        {/* Debug output */}
                        <div style={{ position: 'absolute', top: 0, left: 0, color: 'yellow', fontSize: '12px', zIndex: 1000 }}>
                            Lines: {lines.length}, Texts: {texts.length}
                        </div>

                        {/* Render lines */}
                        <svg
                            style={{
                                position: 'absolute',
                                left: 0,
                                top: 0,
                                width: '100%',
                                height: '100%',
                                pointerEvents: 'none',
                                zIndex: 1,
                                overflow: 'visible'
                            }}
                        >
                            {(lines || []).map((line, index) => (
                                <line
                                    key={`line-${index}`}
                                    x1={line.points?.[0] || 0}
                                    y1={line.points?.[1] || 0}
                                    x2={line.points?.[2] || 0}
                                    y2={line.points?.[3] || 0}
                                    stroke={line.color || '#fff'}
                                    strokeWidth={line.width || 2}
                                    vectorEffect="non-scaling-stroke"
                                />
                            ))}
                        </svg>

                        {/* Render texts */}
                        <svg
                            style={{
                                position: 'absolute',
                                left: 0,
                                top: 0,
                                width: '100%',
                                height: '100%',
                                pointerEvents: 'none',
                                zIndex: 2,
                                overflow: 'visible'
                            }}
                        >
                            {(texts || []).map((text, index) => (
                                <text
                                    key={`text-${index}`}
                                    x={text.x}
                                    y={text.y}
                                    fill={text.color || '#fff'}
                                    style={{ 
                                        fontSize: `${text.size || text.fontSize || 16}px`,
                                        textShadow: '1px 1px 2px black',
                                        userSelect: 'none'
                                    }}
                                    dominantBaseline="middle"
                                    textAnchor="middle"
                                    filter="drop-shadow(1px 1px 2px rgba(0,0,0,0.8))"
                                >
                                    {text.text || text.content || 'Text'}
                                </text>
                            ))}
                        </svg>

                        {layout.parking_slots.map(slot => (
                        <div
                            key={slot.id}
                            className={`${styles.parkingSpace} ${slot.space_status === 'occupied' ? styles.occupied : ''}`}
                            style={{
                                left: slot.x_coordinate ? `${slot.x_coordinate}px` : `${slot.position_x}px`,
                                top: slot.y_coordinate ? `${slot.y_coordinate}px` : `${slot.position_y}px`,
                                width: `${slot.width}px`,
                                height: `${slot.height}px`,
                                transform: `rotate(${slot.rotation || 0}deg)`,
                                position: 'absolute',
                                pointerEvents: isDragging && !slot.space_status === 'occupied' ? 'none' : 'auto'
                            }}
                            onClick={() => handleSlotClick(slot)}
                            draggable={slot.space_status === 'occupied'}
                            onDragStart={(e) => handleDragStart(e, slot)}
                            onDragEnd={handleDragEnd}
                            onDragOver={handleDragOver}
                            onDrop={(e) => handleDrop(e, slot)}
                        >
                            <span className={styles.spaceNumber}>
                                {slot.space_status === 'occupied' ? (
                                    <>
                                        <FaCar className={styles.carIcon} />
                                        <div className={`${styles.tooltip} ${assignments[slot.id]?.assignment_type === 'reserve' ? styles.reservedTooltip : ''}`}>
                                            <div className={styles.tooltipContent}>
                                                <div className={styles.tooltipRow}>
                                                    <span className={styles.tooltipLabel}>Name:</span>
                                                    <span>{assignments[slot.id]?.guest_name || assignments[slot.id]?.name}</span>
                                                </div>
                                                <div className={styles.tooltipRow}>
                                                    <span className={styles.tooltipLabel}>Contact:</span>
                                                    <span>{assignments[slot.id]?.guest_contact}</span>
                                                </div>
                                                <div className={styles.tooltipRow}>
                                                    <span className={styles.tooltipLabel}>Vehicle:</span>
                                                    <span>{assignments[slot.id]?.vehicle_type}</span>
                                                </div>
                                                <div className={styles.tooltipRow}>
                                                    <span className={styles.tooltipLabel}>Plate:</span>
                                                    <span>{assignments[slot.id]?.vehicle_plate}</span>
                                                </div>
                                            </div>
                                            <button 
                                                className={styles.unassignButton}
                                                onClick={async (e) => {
                                                    e.stopPropagation();
                                                    if (window.confirm('Are you sure you want to unassign this parking space?')) {
                                                        try {
                                                            console.log('Unassigning slot:', slot.id);
                                                            console.log('Assignment:', assignments[slot.id]);
                                                            
                                                            const token = localStorage.getItem('token');
                                                            const assignmentId = assignments[slot.id]?.id;
                                                            
                                                            if (!assignmentId) {
                                                                throw new Error('No valid assignment ID found');
                                                            }
                                                            
                                                            await axios.post(
                                                                `http://localhost:8000/api/parking-assignments/${assignmentId}/end`,
                                                                {},
                                                                {
                                                                    headers: { 
                                                                        'Authorization': `Bearer ${token}`,
                                                                        'Accept': 'application/json',
                                                                        'Content-Type': 'application/json'
                                                                    }
                                                                }
                                                            );
                                                            
                                                            // Update local state
                                                            setAssignments(prev => {
                                                                const newAssignments = { ...prev };
                                                                delete newAssignments[slot.id];
                                                                return newAssignments;
                                                            });

                                                            // Update layout state
                                                            setLayout(prev => ({
                                                                ...prev,
                                                                parking_slots: prev.parking_slots.map(s =>
                                                                    s.id === slot.id
                                                                        ? { ...s, space_status: 'available' }
                                                                        : s
                                                                )
                                                            }));

                                                            alert('Parking space unassigned successfully!');
                                                        } catch (error) {
                                                            console.error('Error unassigning space:', error);
                                                            alert('Failed to unassign parking space');
                                                        }
                                                    }
                                                }}
                                            >
                                                Unassign
                                            </button>
                                        </div>
                                    </>
                                ) : (
                                    slot.name || slot.space_number || slot.slot_number
                                )}
                            </span>
                        </div>
                        ))}
                    </div>
                </div>
            </div>

            {showForm && (
                <div className={styles.formContainer}>
                    <div className={styles.formHeader}>
                        <h2>Assign Space {selectedSlot.slot_number}</h2>
                        <button 
                            className={styles.closeButton}
                            onClick={() => setShowForm(false)}
                        >
                            ×
                        </button>
                    </div>
                    
                    <form onSubmit={handleAssignment}>


                        <div className={styles.formGroup}>
                            <label>User Type</label>
                            <div className={styles.radioGroup}>
                                <label>
                                    <input
                                        type="radio"
                                        name="assignee_type"
                                        value="guest"
                                        checked={formData.assignee_type === 'guest'}
                                        onChange={handleInputChange}
                                    />
                                    Guest
                                </label>
                                <label>
                                    <input
                                        type="radio"
                                        name="assignee_type"
                                        value="faculty"
                                        checked={formData.assignee_type === 'faculty'}
                                        onChange={handleInputChange}
                                    />
                                    Faculty
                                </label>
                            </div>
                        </div>

                        <div className={styles.formGroup}>
                            <label>{formData.assignee_type === 'faculty' ? 'Faculty Name' : 'Guest Name'}</label>
                            <input
                                type="text"
                                name="name"
                                value={formData.name}
                                onChange={handleInputChange}
                                required
                            />
                        </div>

                        <div className={styles.formGroup}>
                            <label>Contact Number</label>
                            <input
                                type="text"
                                name="contact"
                                value={formData.contact}
                                onChange={handleInputChange}
                                required
                            />
                        </div>

                        <div className={styles.formGroup}>
                            <label>Vehicle Type</label>
                            <select
                                name="vehicle_type"
                                value={formData.vehicle_type}
                                onChange={handleInputChange}
                                required
                            >
                                <option value="">Select vehicle type</option>
                                <option value="car">Car</option>
                                <option value="motorcycle">Motorcycle</option>
                                <option value="bicycle">Bicycle</option>
                            </select>
                        </div>

                        <div className={styles.formGroup}>
                            <label>Vehicle Plate Number</label>
                            <input
                                type="text"
                                name="vehicle_plate"
                                value={formData.vehicle_plate}
                                onChange={handleInputChange}
                                required
                            />
                        </div>

                        <div className={styles.formGroup}>
                            <label>Start Time</label>
                            <input
                                type="datetime-local"
                                name="start_time"
                                value={formData.start_time}
                                onChange={handleInputChange}
                                required
                            />
                        </div>

                        <div className={styles.formGroup}>
                            <label>End Time (Optional)</label>
                            <input
                                type="datetime-local"
                                name="end_time"
                                value={formData.end_time}
                                onChange={handleInputChange}
                            />
                        </div>

                        <div className={styles.formGroup}>
                            <label>Purpose of Visit</label>
                            <textarea
                                name="purpose"
                                value={formData.purpose}
                                onChange={handleInputChange}
                                rows="3"
                                required
                            />
                        </div>

                        <div className={styles.formActions}>
                            <button 
                                type="submit" 
                                className={`${styles.submitButton} ${formData.assignment_type === 'reserve' ? styles.reserveButton : ''}`}
                            >
                                {formData.assignment_type === 'assign' ? 'Assign Space' : 'Reserve Space'}
                            </button>
                        </div>
                    </form>
                </div>
            )}
        </div>
    );
};

export default ParkingAssignmentPage;


